This file is a merged representation of the entire codebase, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
4. Repository files, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

<additional_info>

</additional_info>

</file_summary>

<directory_structure>
src/
  app/
    globals.css
    layout.tsx
    page.tsx
  components/
    ChessBoard.tsx
  enums/
    ChessPiece.ts
    ChessPieceColor.ts
    ChessSquare.ts
  types/
    StatsStore.d.ts
  utils/
    ChessEngine.ts
    sanToSquare.test.ts
    sanToSquare.ts
    Scheduler.ts
    StatsStore.ts
    TrainingOrchestrator.test.ts
    TrainingOrchestrator.ts
    VariationParser.ts
.repomixignore
eslint.config.mjs
jest.config.js
next.config.ts
package.json
postcss.config.mjs
repomix.config.json
tsconfig.json
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path="src/app/globals.css">
@import "tailwindcss";

:root {
  --background: #ffffff;
  --foreground: #171717;
}

@theme inline {
  --color-background: var(--background);
  --color-foreground: var(--foreground);
  --font-sans: var(--font-geist-sans);
  --font-mono: var(--font-geist-mono);
}

@media (prefers-color-scheme: dark) {
  :root {
    --background: #0a0a0a;
    --foreground: #ededed;
  }
}

body {
  background: var(--background);
  color: var(--foreground);
  font-family: Arial, Helvetica, sans-serif;
}
</file>

<file path="src/app/layout.tsx">
import type { Metadata } from "next";
import { Geist, Geist_Mono } from "next/font/google";
import "./globals.css";

const geistSans = Geist({
  variable: "--font-geist-sans",
  subsets: ["latin"],
});

const geistMono = Geist_Mono({
  variable: "--font-geist-mono",
  subsets: ["latin"],
});

export const metadata: Metadata = {
  title: "Create Next App",
  description: "Generated by create next app",
};

export default function RootLayout({
  children,
}: Readonly<{
  children: React.ReactNode;
}>) {
  return (
    <html lang="en">
      <body
        className={`${geistSans.variable} ${geistMono.variable} antialiased`}
      >
        {children}
      </body>
    </html>
  );
}
</file>

<file path="src/components/ChessBoard.tsx">
'use client';

import { Chess, Piece, Square } from 'chess.js';
import { get } from 'http';
import React, { useState } from 'react';
import { Chessboard } from 'react-chessboard';

interface ChessBoardProps {
  position: string;
  onDrop: {
    (sourceSquare: Square, targetSquare: Square, piece: Piece): boolean;
  };
}

/**
 * @param {{position:string, onDrop:OnDropType}: ChessBoardProps} props
 * @returns {React.JSX.Element}
 * @description A chessboard component that displays the current position of the chess pieces and allows the user to move them.
 * @example
 * <ChessBoard
 *    position="start"
 *    onDrop={
 *      (sourceSquare, targetSquare) => console.log(sourceSquare, targetSquare)
 *    }
 * />
 */
export function ChessBoard({}: ChessBoardProps): React.JSX.Element {
  const [game, setGame] = useState(new Chess());
  const [moveFrom, setMoveFrom] = useState('');
  const [moveTo, setMoveTo] = useState<Square | null>(null);
  const [showPromotionDialog, setShowPromotionDialog] = useState(false);
  const [rightClickedSquares, setRightClickedSquares] = useState({});
  const [moveSquares, setMoveSquares] = useState({});
  const [optionSquares, setOptionSquares] = useState({});

  function isPieceOnSquare(square: Square): boolean {
    const piece = game.get(square);
    return !(piece === null);
  }

  function getPieceOnSquare(square: Square): string {
    const piece = game.get(square);
    if (piece) {
      return piece.type;
    }
    return '';
  }

  function getPieceColorOnSquare(square: Square): string | null {
    const piece = game.get(square);
    if (piece) {
      return piece.color;
    }
    return null;
  }

  function getPieceTypeOnSquare(square: Square): string {
    const piece = game.get(square);
    if (piece) {
      return piece.type;
    }
    return '';
  }

  function findLegalMoveSquares(square: Square): string[] {
    const piece = getPieceOnSquare(square);
    const pieceColor = getPieceColorOnSquare(square);
    const pieceType = getPieceTypeOnSquare(square);
    if (!piece) {
      return [];
    }

    if (!pieceColor || !pieceType) {
      return [];
    }

    const moves = game.moves({
      square,
      verbose: true,
    });
    const legalMoves = moves.filter((move: any) => {
      const movePiece = game.get(move.to) || null;
      if (movePiece) {
        return movePiece.color !== pieceColor;
      } else {
        return true;
      }
    });
    return legalMoves.map((move: any) => move.to);
  }

  function isWhitePiece(square: Square): boolean {
    return getPieceColorOnSquare(square) === 'w';
  }

  function isBlackPiece(square: Square): boolean {
    return getPieceColorOnSquare(square) === 'b';
  }

  function isPawn(square: Square): boolean {
    return getPieceTypeOnSquare(square) === 'p';
  }

  function isKnight(square: Square): boolean {
    return getPieceTypeOnSquare(square) === 'n';
  }

  function isBishop(square: Square): boolean {
    return getPieceTypeOnSquare(square) === 'b';
  }

  function isRook(square: Square): boolean {
    return getPieceTypeOnSquare(square) === 'r';
  }

  function isQueen(square: Square): boolean {
    return getPieceTypeOnSquare(square) === 'q';
  }

  function isKing(square: Square): boolean {
    return getPieceTypeOnSquare(square) === 'k';
  }

  function hasValidMove(square: Square): boolean {
    const piece = game.get(square);
    if (!piece) {
      return false;
    }
    const pieceColor = getPieceColorOnSquare(square);
    const pieceType = getPieceTypeOnSquare(square);
    const moves = game.moves({
      square,
      verbose: true,
    });
    const legalMoves = moves.filter((move: any) => {
      const movePiece = game.get(move.to) || null;
      if (movePiece) {
        return getPieceColorOnSquare(move.to) !== pieceColor;
      } else {
        return true;
      }
    });
    return legalMoves.length > 0;
  }

  function isPromotionMove(square: Square): boolean {
    const piece = game.get(square);
    if (!piece) {
      return false;
    }

    // A white pawn can promote on rank 8/black on rank 1
    const isWhitePromotion = isWhitePiece(square) && square[1] === '8';
    const isBlackPromotion = isBlackPiece(square) && square[1] === '1';

    // A promotion move is a pawn that has reached the last rank
    return isPawn(square) && (isWhitePromotion || isBlackPromotion);
  }

  function onSquareClick(square: Square) {
    setRightClickedSquares({});

    const currentSquare = square as string;
    const piece = getPieceOnSquare(square);
    const pieceColor = getPieceColorOnSquare(square);
    const pieceType = getPieceTypeOnSquare(square);

    // to square
    if (!moveTo) {
      // check if valid move before showing dialog
      if (!hasValidMove(square)) {
        return;
      }

      // valid move
      setMoveTo(square);

      // if promotion move
      if (isPromotionMove(square)) {
        // show promotion dialog
        setShowPromotionDialog(true);
        return;
      }

      // is normal move
      const gameCopy: any = {
        ...game,
      };
      const move = gameCopy.move({
        from: moveFrom,
        to: square,
        promotion: 'q',
      });

      setGame(gameCopy);
      setMoveFrom('');
      setMoveTo(null);
      setOptionSquares({});
      return;
    }
  }

  function onPromotionPieceSelect(piece: string[]) {
    // if no piece passed then user has cancelled dialog, don't make move and reset
    if (piece) {
      const gameCopy: any = {
        ...game,
      };
      gameCopy.move({
        from: moveFrom,
        to: moveTo || '',
        promotion: piece[1].toLowerCase() ?? 'q',
      });
      setGame(gameCopy);
    }
    setMoveFrom('');
    setMoveTo(null);
    setShowPromotionDialog(false);
    setOptionSquares({});
    return true;
  }

  function onSquareRightClick(square: string | number) {
    const colour = 'rgba(0, 0, 255, 0.4)';
    setRightClickedSquares({
      ...rightClickedSquares,
      [square]: {
        backgroundColor: colour,
        borderRadius: '50%',
        boxShadow: `0 0 10px ${colour}`,
      },
    });
  }

  return (
    <div>
      <Chessboard
        id="ClickToMove"
        animationDuration={200}
        arePiecesDraggable={false}
        position={game.fen()}
        onSquareClick={onSquareClick}
        onSquareRightClick={onSquareRightClick}
        customBoardStyle={{
          borderRadius: '4px',
          boxShadow: '0 2px 10px rgba(0, 0, 0, 0.5)',
        }}
        customSquareStyles={{
          ...moveSquares,
          ...optionSquares,
          ...rightClickedSquares,
        }}
        promotionToSquare={moveTo}
        showPromotionDialog={showPromotionDialog}
      />
    </div>
  );
}
</file>

<file path="src/enums/ChessPiece.ts">
export enum ChessPiece {
  Pawn = 'p',
  Knight = 'n',
  Bishop = 'b',
  Rook = 'r',
  Queen = 'q',
  King = 'k'
}
</file>

<file path="src/enums/ChessPieceColor.ts">
export enum ChessPieceColor {
  White = 1,
  Black = 0
}
</file>

<file path="src/enums/ChessSquare.ts">
/**
 * ChessSquare enum represents the squares on a chessboard.
 * Each square is represented by a unique number from 0 to 63.
 * The squares are arranged in a standard chessboard layout, starting from A1 to H8.
 */
export enum ChessSquare {
  A1 = 0,
  A2 = 1,
  A3 = 2,
  A4 = 3,
  A5 = 4,
  A6 = 5,
  A7 = 6,
  A8 = 7,
  B1 = 8,
  B2 = 9,
  B3 = 10,
  B4 = 11,
  B5 = 12,
  B6 = 13,
  B7 = 14,
  B8 = 15,
  C1 = 16,
  C2 = 17,
  C3 = 18,
  C4 = 19,
  C5 = 20,
  C6 = 21,
  C7 = 22,
  C8 = 23,
  D1 = 24,
  D2 = 25,
  D3 = 26,
  D4 = 27,
  D5 = 28,
  D6 = 29,
  D7 = 30,
  D8 = 31,
  E1 = 32,
  E2 = 33,
  E3 = 34,
  E4 = 35,
  E5 = 36,
  E6 = 37,
  E7 = 38,
  E8 = 39,
  F1 = 40,
  F2 = 41,
  F3 = 42,
  F4 = 43,
  F5 = 44,
  F6 = 45,
  F7 = 46,
  F8 = 47,
  G1 = 48,
  G2 = 49,
  G3 = 50,
  G4 = 51,
  G5 = 52,
  G6 = 53,
  G7 = 54,
  G8 = 55,
  H1 = 56,
  H2 = 57,
  H3 = 58,
  H4 = 59,
  H5 = 60,
  H6 = 61,
  H7 = 62,
  H8 = 63
}
</file>

<file path="src/types/StatsStore.d.ts">
export type StatsKey = string | number;

/**
 * @typedef {Object} StatsEntry
 * @property {number} attempts - Number of attempts for this variation.
 * @property {number} successes - Number of successful attempts for this variation.
 */
export interface StatsEntry {
  attempts: number;
  successes: number;
}
</file>

<file path="src/utils/ChessEngine.ts">
import { Chess } from 'chess.js';

/**
 * @interface IChessEngine
 * @method loadPgn
 * @method makeMove
 * @method reset
 */

/**
 * ChessEngine wraps chess.js to provide a clean interface.
 */
export class ChessEngine {
  game: Chess;
  constructor() {
    /** @private */
    this.game = new Chess();
  }

  /**
   * Load a full PGN string into the engine.
   * @param {string} pgn - PGN text.
   * @returns {boolean} True if parsed successfully.
   */
  loadPgn(pgn: string) {
    return this.game.loadPgn(
      pgn,
      { sloppy: true } as any // TODO: Add interface for "LoadPgnOptions" with sloppy, string, newLineChar
    );
  }

  /**
   * Attempt a move in SAN or {from,to} format.
   * @param {string|object} move - SAN string or move object.
   * @returns {object|null} The move object if legal, else null.
   */
  makeMove(move: string | { from: string; to: string; promotion?: string; }) {
    return this.game.move(move) || null;
  }

  /**
   * Get the current move history in verbose form.
   * @returns {Array<object>}
   */
  getHistory() {
    return this.game.history({ verbose: true });
  }

  /**
   * Reset the game to initial position.
   */
  reset() {
    this.game.reset();
  }
}
</file>

<file path="src/utils/sanToSquare.test.ts">
import sanToSquare from '@/utils/sanToSquare';
import { ChessSquare } from '@/enums/ChessSquare';
import { describe, test, expect } from '@jest/globals';

describe('sanToSquare', () => {
  test('should convert "a1" to ChessSquare.A1', () => {
    expect(sanToSquare('a1')).toBe(ChessSquare.A1);
  });

  test('should convert "h1" to ChessSquare.H1', () => {
    expect(sanToSquare('h1')).toBe(ChessSquare.H1);
  });

  test('should convert "a8" to ChessSquare.A8', () => {
    expect(sanToSquare('a8')).toBe(ChessSquare.A8);
  });

  test('should convert "h8" to ChessSquare.H8', () => {
    expect(sanToSquare('h8')).toBe(ChessSquare.H8);
  });

  test('should convert "e4" to ChessSquare.E4', () => {
    expect(sanToSquare('e4')).toBe(ChessSquare.E4);
  });

  test('should convert "d5" to ChessSquare.D5', () => {
    expect(sanToSquare('d5')).toBe(ChessSquare.D5);
  });

  test('should convert "c3" to ChessSquare.C3', () => {
    expect(sanToSquare('c3')).toBe(ChessSquare.C3);
  });

  test('should convert "f6" to ChessSquare.F6', () => {
    expect(sanToSquare('f6')).toBe(ChessSquare.F6);
  });
});
</file>

<file path="src/utils/sanToSquare.ts">
import { ChessSquare } from "@/enums/ChessSquare";

interface FileToIdx {
  [key: string]: number;
}

/**
 * sanToSquare function converts a standard algebraic notation (SAN) string to a ChessSquare enum value.
 * The SAN string should be in the format of a chess move, e.g., "e4", "Nf3", etc.
 * The function returns the corresponding ChessSquare enum value.
 */
export default function sanToSquare(san: string): ChessSquare {
  const fileToIdx: FileToIdx = {
    a: 0,
    b: 1,
    c: 2,
    d: 3,
    e: 4,
    f: 5,
    g: 6,
    h: 7,
  }
  const fileChar = san.charAt(0).toLowerCase();
  const file = fileToIdx[fileChar];
  const rankChar = san.charAt(1);
  const rank = parseInt(rankChar, 10) - 1;
  if (isNaN(rank) || rank < 0 || rank > 7 || file === undefined) {
    throw new Error(`Invalid SAN: ${san}`);
  }
  if (file < 0 || file > 7) {
    throw new Error(`Invalid file: ${fileChar}`);
  }
  return file*8 + rank as ChessSquare;
}
</file>

<file path="src/utils/Scheduler.ts">
import { fsrs, generatorParameters, createEmptyCard, Rating } from 'ts-fsrs';

enum State {
  New = 0,
  Learning = 1,
  Review = 2,
  Relearning = 3,
}

interface Card {
    difficulty: number;
    due: Date;
    elapsed_days: number;
    lapses: number;
    last_review?: Date;
    reps: number;
    scheduled_days: number;
    stability: number;
    state: State;
}

/**
 * Scheduler wraps ts-fsrs to compute next review intervals.
 */
export class Scheduler {
  scheduler: any;
  constructor() {
    const params = generatorParameters({ enable_fuzz: true });
    /** @private */
    this.scheduler = fsrs(params);
  }

  /**
   * Create a new card state at a given date.
   * @param {Date} date 
   * @returns {Card} FSRS card.
   */
  createCard(date: Date = new Date()): Card {
    return createEmptyCard(date);
  }

  /**
   * Given a card and a quality rating, compute next intervals.
   * @param {Card} card - FSRS card.
   * @param {Rating} quality - Recall quality (0=Forgot,4=Mastered).
   * @returns {Card[]} Next scheduled card states.
   */
  schedule(card: Card, quality: Rating): Card[] {
    return this.scheduler.repeat(card, new Date(), quality);
  }
}
</file>

<file path="src/utils/StatsStore.ts">
import { StatsKey, StatsEntry } from "@/types/StatsStore";


/**
 * StatsStore tracks attempts and successes keyed by variation.
 */
export class StatsStore {
  private store: Record<string, StatsEntry>;
  constructor() {
    /** @private @type {Record<StatsKey, StatsEntry>} */
    this.store = {};
  }

  /**
   * Record a drill result.
   * @param {StatsKey} key - Unique variation key (e.g. SAN sequence).
   * @param {boolean} success - Whether the attempt was correct.
   */
  recordResult(key: StatsKey, success: boolean): void {
    const prev = this.store[key] ?? { attempts: 0, successes: 0 };
    this.store[key] = {
      attempts: prev.attempts + 1,
      successes: prev.successes + (success ? 1 : 0),
    };
  }

  /**
   * Get stats for a variation.
   * @param {StatsKey} key
   * @returns {{attempts:number,successes:number}}
   */
  getStats(key: StatsKey): StatsEntry {
    return this.store[key] || { attempts: 0, successes: 0 };
  }
}
</file>

<file path="src/utils/VariationParser.ts">
import pgnParser from 'pgn-parser';

/**
 * VariationParser extracts a full variation tree from PGN.
 */
export class VariationParser {
  /**
   * Parse PGN and return structured JSON, including RAVs.
   * @param {string} pgn
   * @returns {object} Parsed result (tags + moves + ravs).
   */
  parse(pgn: string) {
    const [result] = pgnParser.parse(pgn);
    return result;
  }
}
</file>

<file path=".repomixignore">
# Add patterns to ignore here, one per line
# Example:
# *.log
# tmp/

package-lock.json 
.next/
.vscode/ 
node_modules/
pubic/
repomix.config.json/
.prettierrc
.gitignore
repomix-output.xml
*.svg
*.prompt
*.md
</file>

<file path="eslint.config.mjs">
import { dirname } from "path";
import { fileURLToPath } from "url";
import { FlatCompat } from "@eslint/eslintrc";

const __filename = fileURLToPath(import.meta.url);
const __dirname = dirname(__filename);

const compat = new FlatCompat({
  baseDirectory: __dirname,
});

const eslintConfig = [
  ...compat.extends("next/core-web-vitals", "next/typescript"),
];

export default eslintConfig;
</file>

<file path="jest.config.js">
// filepath: jest.config.js
/** @type {import('ts-jest').JestConfigWithTsJest} */
module.exports = {
  preset: 'ts-jest',
  testEnvironment: 'node',
  // Optional: Configure path aliases like '@/' if you use them
  moduleNameMapper: {
    '^@/(.*)$': '<rootDir>/src/$1',
  },
};
</file>

<file path="next.config.ts">
import type { NextConfig } from "next";

const nextConfig: NextConfig = {
  /* config options here */
};

export default nextConfig;
</file>

<file path="postcss.config.mjs">
const config = {
  plugins: ["@tailwindcss/postcss"],
};

export default config;
</file>

<file path="repomix.config.json">
{
  "input": {
    "maxFileSize": 52428800
  },
  "output": {
    "filePath": "repomix-output.xml",
    "style": "xml",
    "parsableStyle": false,
    "fileSummary": true,
    "directoryStructure": true,
    "files": true,
    "removeComments": false,
    "removeEmptyLines": false,
    "compress": false,
    "topFilesLength": 5,
    "showLineNumbers": false,
    "copyToClipboard": false,
    "git": {
      "sortByChanges": true,
      "sortByChangesMaxCommits": 100
    }
  },
  "include": [],
  "ignore": {
    "useGitignore": true,
    "useDefaultPatterns": true,
    "customPatterns": []
  },
  "security": {
    "enableSecurityCheck": true
  },
  "tokenCount": {
    "encoding": "o200k_base"
  }
}
</file>

<file path="tsconfig.json">
{
  "compilerOptions": {
    "target": "ES2017",
    "lib": ["dom", "dom.iterable", "esnext"],
    "allowJs": true,
    "skipLibCheck": true,
    "strict": true,
    "noEmit": true,
    "esModuleInterop": true,
    "module": "esnext",
    "moduleResolution": "bundler",
    "resolveJsonModule": true,
    "isolatedModules": true,
    "jsx": "preserve",
    "incremental": true,
    "plugins": [
      {
        "name": "next"
      }
    ],
    "paths": {
      "@/*": ["./src/*"]
    }
  },
  "include": ["next-env.d.ts", "**/*.ts", "**/*.tsx", ".next/types/**/*.ts"],
  "exclude": ["node_modules"]
}
</file>

<file path="src/app/page.tsx">
'use client';
import { ChessBoard } from "@/components/ChessBoard";

export default function Home() {
  return (
    <div className="flex items-center justify-items-center min-h-screen p-8 pb-20 gap-16 sm:p-20 font-[family-name:var(--font-geist-sans)]">
        <ChessBoard 
          position="start"
          onDrop={(sourceSquare, targetSquare) =>
            true
          }
        />
    </div>
  );
}
</file>

<file path="package.json">
{
  "name": "chess-drill",
  "version": "0.1.0",
  "private": true,
  "scripts": {
    "dev": "next dev --turbopack",
    "build": "next build",
    "start": "next start",
    "lint": "next lint",
    "test": "jest --watchAll --passWithNoTests"
  },
  "dependencies": {
    "chess.js": "^1.2.0",
    "next": "15.3.1",
    "pgn-parser": "^2.2.1",
    "react": "^19.0.0",
    "react-chessboard": "^4.7.3",
    "react-dom": "^19.0.0",
    "ts-fsrs": "^4.7.1"
  },
  "devDependencies": {
    "@eslint/eslintrc": "^3",
    "@tailwindcss/postcss": "^4",
    "@testing-library/react": "^16.3.0",
    "@types/node": "^20",
    "@types/pgn-parser": "^2.1.3",
    "@types/react": "^19",
    "@types/react-dom": "^19",
    "eslint": "^9",
    "eslint-config-next": "15.3.1",
    "jest": "^29.7.0",
    "tailwindcss": "^4",
    "ts-jest": "^29.3.2",
    "typescript": "^5"
  }
}
</file>

<file path="src/utils/TrainingOrchestrator.ts">
import { VariationParser } from './VariationParser';

// Define a type for parsed PGN moves, including recursive RAVs
export interface PgnMove {
  move: string;
  comment?: string;
  nag?: string[];
  rav?: PgnRav[]; // Changed from singular "rav" to match test expectations
  [key: string]: any; // For any other properties that might exist
}

export interface PgnRav {
  moves: PgnMove[];
}

// The overall structure of parsed PGN data
export interface ParsedPgn {
  moves: PgnMove[];
  tags?: Record<string, string>;
  result?: string;
  // Other properties that might be present in parsed PGN
}

// Structure for flattened variation lines
export interface VariationLine {
  moves: PgnMove[]; // Without 'rav' properties
  tags?: Record<string, string>; // Tags from the original PGN
}

// Interface for the objects expected in the array passed to generateVariationKey
interface MoveForVariationKey {
  move: string;
  // Allow other properties to exist on the object, but they won't be used for the key.
  [key: string]: any;
}

export class TrainingOrchestrator {
  private variationParser: VariationParser;
  private parsedPgn: ParsedPgn | null = null;

  constructor() {
    this.variationParser = new VariationParser();
  }

  public loadPgn(pgnString: string): void {
    if (!pgnString) {
      throw new Error('PGN string cannot be empty.');
    }
    this.parsedPgn = this.variationParser.parse(pgnString);
    // TODO: Add more robust error handling if parse can fail
  }

  public getParsedPgn(): ParsedPgn | null {
    return this.parsedPgn;
  }

  public hasPgnLoaded(): boolean {
    return this.parsedPgn !== null;
  }

  public generateVariationKey(variationMoves: MoveForVariationKey[]): string {
    if (!variationMoves || variationMoves.length === 0) {
      return '';
    }
    // Create the key by joining only the 'move' property of each object
    return variationMoves.map((m) => m.move).join('_');
  }

  /**
   * Flattens a parsed PGN structure with nested variations (RAVs) into a list of distinct playable lines.
   *
   * @param pgnData The parsed PGN data to flatten. If null, returns an empty array.
   * @returns An array of VariationLine objects, each representing a complete playable variation.
   */
  public flattenVariations(pgnData: ParsedPgn | null): VariationLine[] {
    if (!pgnData || !pgnData.moves || pgnData.moves.length === 0) {
      return [];
    }

    const flatVariations: VariationLine[] = [];
    const tags = pgnData.tags;

    // Helper function to create a deep copy of a move without rav property
    const copyMoveWithoutRav = (move: PgnMove): PgnMove => {
      const { rav, ...moveCopy } = move;
      return moveCopy;
    };

    // DFS function to build all possible variation lines
    const buildVariations = (currentPath: PgnMove[], movesArray: PgnMove[]) => {
      if (movesArray.length === 0) {
        return;
      }

      let currentLine = [...currentPath];

      // Process each move in the current sequence
      for (let i = 0; i < movesArray.length; i++) {
        const move = movesArray[i];

        // First, process any RAVs (alternative variations) from this position
        if (move.rav && move.rav.length > 0) {
          // For each RAV, start a new variation from the current path
          for (const rav of move.rav) {
            if (rav.moves && rav.moves.length > 0) {
              buildVariations(currentLine, rav.moves);
            }
          }
        }

        // Add the current move to our path (without its RAVs)
        currentLine.push(copyMoveWithoutRav(move));

        // If this is the last move in the sequence, add the completed line to our results
        if (i === movesArray.length - 1) {
          flatVariations.push({
            moves: [...currentLine],
            tags,
          });
        }
      }
    };

    // Start building variations from the root moves
    buildVariations([], pgnData.moves);

    return flatVariations;
  }
}
</file>

<file path="src/utils/TrainingOrchestrator.test.ts">
import { TrainingOrchestrator } from '@/utils/TrainingOrchestrator';
import { describe, test, expect, jest, beforeEach } from '@jest/globals'; // Import jest
import { VariationParser } from '@/utils/VariationParser'; // Import VariationParser

// Mock VariationParser
jest.mock('@/utils/VariationParser'); // Corrected mock path

const mockParse = jest.fn();
VariationParser.prototype.parse = mockParse;

// A helper type for the mock PGN data to ensure consistency
export interface MockMove {
  move: string;
  comment?: string;
  nag?: string[];
  rav?: MockRav[]; // For nested variations
  // Potentially other PGN move properties
}

// Define a type for RAV (Recursive Annotation Variation)
export interface MockRav {
  moves: MockMove[];
  // Potentially other RAV properties
}

// A helper type for the mock PGN data to ensure consistency
export interface MockParsedPgnData {
  moves: MockMove[];
  result?: string;
  tags?: Record<string, any>; // Allow any for tags in mock
  // Potentially other top-level PGN properties
}

interface MockParsedPgnWithComments extends MockParsedPgnData {
  comments: string[];
}
interface MockParsedPgnWithNags extends MockParsedPgnData {
  nags: string[];
}
interface MockParsedPgnWithRav extends MockParsedPgnData {
  rav: { moves: { move: string }[] }[];
}

describe('TrainingOrchestrator', () => {
  beforeEach(() => {
    // Clear mock calls before each test
    mockParse.mockClear();
    // Reset mock return value for each test if necessary
    mockParse.mockReturnValue(undefined);
  });
  test('constructor(): should be able to instantiate', () => {
    const orchestrator = new TrainingOrchestrator();
    expect(orchestrator).toBeDefined();
  });

  describe('loadPgn', () => {
    test('should throw an error if the PGN string is empty', () => {
      const orchestrator = new TrainingOrchestrator();
      expect(() => orchestrator.loadPgn('')).toThrow(
        'PGN string cannot be empty.',
      );
    });

    test('should parse and store a simple PGN string', () => {
      const orchestrator = new TrainingOrchestrator();
      const pgnString = '1. e4 e5';
      const mockParsedPgn: MockParsedPgnData = {
        moves: [{ move: 'e4' }, { move: 'e5' }],
        result: '*',
        tags: {},
      };
      mockParse.mockReturnValue(mockParsedPgn);

      orchestrator.loadPgn(pgnString);

      expect(mockParse).toHaveBeenCalledWith(pgnString);
      expect(orchestrator.getParsedPgn()).toEqual(mockParsedPgn); // Verify storage
    });

    test('getParsedPgn() should return null if PGN has not been loaded', () => {
      const orchestrator = new TrainingOrchestrator();
      expect(orchestrator.getParsedPgn()).toBeNull();
    });

    test('loadPgn() should store null if VariationParser returns null (e.g. invalid PGN)', () => {
      const orchestrator = new TrainingOrchestrator();
      const pgnString = 'invalid pgn';
      mockParse.mockReturnValue(null); // Simulate parser returning null for invalid PGN

      orchestrator.loadPgn(pgnString);

      expect(mockParse).toHaveBeenCalledWith(pgnString);
      expect(orchestrator.getParsedPgn()).toBeNull();
    });
  });

  describe('loadPgn with complex PGNs', () => {
    test('should correctly parse PGN with comments', () => {
      const orchestrator = new TrainingOrchestrator();
      const pgnStringWithComment = '1. e4 {This is a comment} e5';
      // Define what the mock parser should return, including comments if your structure supports it
      const mockParsedPgnWithComment: MockParsedPgnData = {
        moves: [
          { move: 'e4', comment: 'This is a comment' }, // Assuming comments are attached to moves
          { move: 'e5' },
        ],
        result: '*',
        tags: {},
      };
      mockParse.mockReturnValue(mockParsedPgnWithComment);
      orchestrator.loadPgn(pgnStringWithComment);
      expect(mockParse).toHaveBeenCalledWith(pgnStringWithComment);
      expect(orchestrator.getParsedPgn()).toEqual(mockParsedPgnWithComment);
    });

    test('should correctly parse PGN with NAGs', () => {
      const orchestrator = new TrainingOrchestrator();
      const pgnStringWithNag = '1. e4 $1 e5'; // $1 is a common NAG for good move
      const mockParsedPgnWithNag: MockParsedPgnData = {
        moves: [
          { move: 'e4', nag: ['$1'] }, // Assuming NAGs are in an array
          { move: 'e5' },
        ],
        result: '*',
        tags: {},
      };
      mockParse.mockReturnValue(mockParsedPgnWithNag);
      orchestrator.loadPgn(pgnStringWithNag);
      expect(mockParse).toHaveBeenCalledWith(pgnStringWithNag);
      expect(orchestrator.getParsedPgn()).toEqual(mockParsedPgnWithNag);
    });

    // Test for nested variations will be more complex and might require adjustments
    // to MockParsedPgnData and the mock implementation of VariationParser
    // For now, this is a placeholder structure
    test('should correctly parse PGN with nested variations (RAVs)', () => {
      const orchestrator = new TrainingOrchestrator();
      const pgnStringWithRav = '1. e4 (1... d5 2. exd5) e5';
      const mockParsedPgnWithRav = {
        moves: [
          {
            move: 'e4',
            rav: [{ moves: [{ move: 'd5' }, { move: 'exd5' }] }], // Simplified RAV structure
          },
          { move: 'e5' },
        ],
        result: '*',
        tags: {},
      } as any; // Using 'as any' for now due to complex structure
      mockParse.mockReturnValue(mockParsedPgnWithRav);
      orchestrator.loadPgn(pgnStringWithRav);
      expect(mockParse).toHaveBeenCalledWith(pgnStringWithRav);
      expect(orchestrator.getParsedPgn()).toEqual(mockParsedPgnWithRav);
    });
  });

  describe('hasPgnLoaded', () => {
    test('should return false if PGN has not been loaded', () => {
      const orchestrator = new TrainingOrchestrator();
      expect(orchestrator.hasPgnLoaded()).toBe(false);
    });

    test('should return true if PGN has been successfully loaded', () => {
      const orchestrator = new TrainingOrchestrator();
      const pgnString = '1. e4 e5';
      const mockParsedPgn: MockParsedPgnData = {
        moves: [{ move: 'e4' }, { move: 'e5' }],
        result: '*',
        tags: {},
      };
      mockParse.mockReturnValue(mockParsedPgn);
      orchestrator.loadPgn(pgnString);
      expect(orchestrator.hasPgnLoaded()).toBe(true);
    });

    test('should return false if PGN loading resulted in null (invalid PGN)', () => {
      const orchestrator = new TrainingOrchestrator();
      const pgnString = 'invalid pgn';
      mockParse.mockReturnValue(null);
      orchestrator.loadPgn(pgnString);
      expect(orchestrator.hasPgnLoaded()).toBe(false);
    });
  });

  describe('generateVariationKey', () => {
    test('should generate a consistent key for a sequence of moves', () => {
      const orchestrator = new TrainingOrchestrator();
      // Use the MockMove type for the moves array
      const moves: MockMove[] = [
        { move: 'e4' },
        { move: 'e5' },
        { move: 'Nf3' },
      ];
      const key1 = orchestrator.generateVariationKey(moves);
      const key2 = orchestrator.generateVariationKey(moves);
      expect(key1).toBe(key2);
      expect(key1).toBe('e4_e5_Nf3');
    });

    test('should generate different keys for different move sequences', () => {
      const orchestrator = new TrainingOrchestrator();
      const moves1: MockMove[] = [{ move: 'e4' }, { move: 'e5' }];
      const moves2: MockMove[] = [{ move: 'd4' }, { move: 'd5' }];
      const key1 = orchestrator.generateVariationKey(moves1);
      const key2 = orchestrator.generateVariationKey(moves2);
      expect(key1).not.toBe(key2);
    });

    test('should handle empty move sequence', () => {
      const orchestrator = new TrainingOrchestrator();
      const moves: MockMove[] = [];
      const key = orchestrator.generateVariationKey(moves);
      expect(key).toBe('');
    });

    test("should generate a key based only on the 'move' property", () => {
      const orchestrator = new TrainingOrchestrator();
      const moves1: MockMove[] = [
        { move: 'e4', comment: 'A comment' },
        { move: 'e5' },
      ];
      const moves2: MockMove[] = [{ move: 'e4' }, { move: 'e5' }];
      const key1 = orchestrator.generateVariationKey(moves1);
      const key2 = orchestrator.generateVariationKey(moves2);
      expect(key1).toBe(key2);
      expect(key1).toBe('e4_e5');
    });
  });

  // New describe block for flattenVariations
  describe('flattenVariations', () => {
    let orchestrator: TrainingOrchestrator;

    beforeEach(() => {
      orchestrator = new TrainingOrchestrator();
      // We don't need to mock VariationParser.parse here as flattenVariations
      // will take the parsed PGN as an argument.
    });

    test('should return an empty array if parsedPgn is null', () => {
      expect(orchestrator.flattenVariations(null)).toEqual([]);
    });

    test('should return an empty array if parsedPgn has no moves', () => {
      const parsedPgn: MockParsedPgnData = { moves: [] };
      expect(orchestrator.flattenVariations(parsedPgn)).toEqual([]);
    });

    test('should return a single variation for a PGN with no RAVs', () => {
      const parsedPgn: MockParsedPgnData = {
        moves: [{ move: 'e4' }, { move: 'e5' }, { move: 'Nf3' }],
        tags: { White: 'User' }, // Example tag
      };
      const expectedFlatVariations = [
        {
          moves: [{ move: 'e4' }, { move: 'e5' }, { move: 'Nf3' }],
          tags: { White: 'User' },
        },
      ];
      expect(orchestrator.flattenVariations(parsedPgn)).toEqual(
        expectedFlatVariations,
      );
    });

    test('should flatten a PGN with a simple RAV at the first move', () => {
      const parsedPgn: MockParsedPgnData = {
        moves: [
          { move: 'e4', rav: [{ moves: [{ move: 'd5' }, { move: 'exd5' }] }] },
          { move: 'e5' },
        ],
        tags: { Event: 'Test Game' },
      };
      const expectedFlatVariations = [
        {
          moves: [{ move: 'e4' }, { move: 'e5' }],
          tags: { Event: 'Test Game' },
        },
        {
          moves: [{ move: 'd5' }, { move: 'exd5' }],
          tags: { Event: 'Test Game' },
        }, // RAV becomes a separate line
      ];
      // Sort for consistent comparison as order might not be guaranteed depending on implementation
      const result = orchestrator
        .flattenVariations(parsedPgn)
        .sort((a, b) => a.moves[0].move.localeCompare(b.moves[0].move));
      expect(result).toEqual(
        expectedFlatVariations.sort((a, b) =>
          a.moves[0].move.localeCompare(b.moves[0].move),
        ),
      );
    });

    test('should flatten a PGN with a RAV deeper in the main line', () => {
      const parsedPgn: MockParsedPgnData = {
        moves: [
          { move: 'e4' },
          { move: 'e5' },
          { move: 'Nf3', rav: [{ moves: [{ move: 'Nc6' }, { move: 'Bb5' }] }] },
          { move: 'Bc4' },
        ],
      };
      const expectedFlatVariations = [
        {
          moves: [
            { move: 'e4' },
            { move: 'e5' },
            { move: 'Nf3' },
            { move: 'Bc4' },
          ],
          tags: undefined,
        },
        {
          moves: [
            { move: 'e4' },
            { move: 'e5' },
            { move: 'Nc6' },
            { move: 'Bb5' },
          ],
          tags: undefined,
        },
      ];
      const result = orchestrator
        .flattenVariations(parsedPgn)
        .sort((a, b) => a.moves[2].move.localeCompare(b.moves[2].move));
      expect(result).toEqual(
        expectedFlatVariations.sort((a, b) =>
          a.moves[2].move.localeCompare(b.moves[2].move),
        ),
      );
    });

    test('should handle multiple RAVs at the same level', () => {
      const parsedPgn: MockParsedPgnData = {
        moves: [
          {
            move: 'e4',
            rav: [
              { moves: [{ move: 'c5' }] }, // Sicilian
              { moves: [{ move: 'e5' }] }, // Open Game
            ],
          },
          // No main line continuation after e4 for this test case
        ],
      };
      const expectedFlatVariations = [
        { moves: [{ move: 'e4' }], tags: undefined }, // Main line up to the branch point
        { moves: [{ move: 'c5' }], tags: undefined },
        { moves: [{ move: 'e5' }], tags: undefined },
      ];
      const result = orchestrator
        .flattenVariations(parsedPgn)
        .sort((a, b) => a.moves[0].move.localeCompare(b.moves[0].move));
      expect(result).toEqual(
        expectedFlatVariations.sort((a, b) =>
          a.moves[0].move.localeCompare(b.moves[0].move),
        ),
      );
    });

    test('should flatten deeply nested RAVs', () => {
      const parsedPgn: MockParsedPgnData = {
        moves: [
          {
            move: 'e4',
            rav: [
              {
                moves: [
                  { move: 'c5' },
                  { move: 'Nf3', rav: [{ moves: [{ move: 'd6' }] }] },
                ],
              },
            ],
          },
          { move: 'd4' }, // Main line continuation
        ],
      };
      const expectedFlatVariations = [
        { moves: [{ move: 'e4' }, { move: 'd4' }], tags: undefined },
        { moves: [{ move: 'c5' }, { move: 'Nf3' }], tags: undefined },
        { moves: [{ move: 'c5' }, { move: 'd6' }], tags: undefined },
      ];
      // Sorting becomes more complex here, might need a more robust comparison or ensure specific order from flattenVariations
      const result = orchestrator.flattenVariations(parsedPgn).sort((a, b) => {
        const len = Math.min(a.moves.length, b.moves.length);
        for (let i = 0; i < len; i++) {
          if (a.moves[i].move !== b.moves[i].move)
            return a.moves[i].move.localeCompare(b.moves[i].move);
        }
        return a.moves.length - b.moves.length;
      });
      const expectedSorted = expectedFlatVariations.sort((a, b) => {
        const len = Math.min(a.moves.length, b.moves.length);
        for (let i = 0; i < len; i++) {
          if (a.moves[i].move !== b.moves[i].move)
            return a.moves[i].move.localeCompare(b.moves[i].move);
        }
        return a.moves.length - b.moves.length;
      });
      expect(result).toEqual(expectedSorted);
    });

    test('should include comments and NAGs in flattened variations if they exist on moves', () => {
      const parsedPgn: MockParsedPgnData = {
        moves: [
          { move: 'e4', comment: 'Good move' },
          {
            move: 'e5',
            nag: ['$1'],
            rav: [{ moves: [{ move: 'd5', comment: 'Alternative' }] }],
          },
        ],
      };
      const expectedFlatVariations = [
        {
          moves: [
            { move: 'e4', comment: 'Good move' },
            { move: 'e5', nag: ['$1'] },
          ],
          tags: undefined,
        },
        {
          moves: [
            { move: 'e4', comment: 'Good move' },
            { move: 'd5', comment: 'Alternative' },
          ],
          tags: undefined,
        },
      ];
      const result = orchestrator
        .flattenVariations(parsedPgn)
        .sort((a, b) => a.moves[1].move.localeCompare(b.moves[1].move));
      expect(result).toEqual(
        expectedFlatVariations.sort((a, b) =>
          a.moves[1].move.localeCompare(b.moves[1].move),
        ),
      );
    });
  });
});
</file>

</files>
